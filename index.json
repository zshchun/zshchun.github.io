[{"content":"파일이 어떤 파일인지 분석할때는 보통 Magic 값을 사용한다.\nLinux 기준으로는 file 또는 binwalk 등의 명령으로 판별할 수 있다.\n하지만 파일에서 패턴이나 Signature로 판별하기 어려운 경우가 있다.\n파일의 패턴이 보이지 않을 경우는 압축 파일 또는 암호화되었거나 serialization 된 경우가 많다.\n이런 경우 File entropy를 이용하면 파일의 편향성을 판별할수 있다.\nShannon\u0026rsquo;s entropy는 데이터가 얼마나 무질서한지를 0-8 사이의 값으로 나타낸다.\n리눅스에서는 ent 명령으로 확인할 수 있다.\nAES를 통해 암호화된 파일의 경우는 패턴이 반복되는 빈도가 낮기 때문에 7 이상의 높은 entropy를 가진다.\n실제 암호화된 파일을 통해 확인해보자.\ndd if=/dev/zero bs=4096 count=256 | openssl enc -aes-128-cbc -in - -out - -K \u0026#34;000102030405060708090a0b0c0d0e0f\u0026#34; -iv \u0026#34;000102030405060708090a0b0c0d0e0f\u0026#34; | ent ... Entropy = 7.999820 bits per byte. ... 다음은 출력가능한 random 값에 대한 경우의 entropy를 보여준다.\ncat /dev/urandom | tr -cd \u0026#39;[:print:]\u0026#39; | dd bs=4096 count=256 | ent ... Entropy = 6.569796 bits per byte. ... 암호화된 파일의 경우 높은 entropy를 확인할 수 있다.\n","permalink":"https://zshchun.github.io/posts/%EC%95%94%ED%98%B8%ED%99%94%EB%90%9C-%ED%8C%8C%EC%9D%BC%EC%9D%98-%ED%8C%90%EB%B3%84/","summary":"파일이 어떤 파일인지 분석할때는 보통 Magic 값을 사용한다. Linux 기준으로는","title":"암호화된 파일의 판별"},{"content":"Linux kernel를 디버깅 하는 방법으로 QEMU와 JTAG을 이용한 방법 등이 있다.\n여기서는 x86 64비트 환경에서 QEMU와 gdb로 디버깅 하는 방법을 설명한다.\n패키지 설치 먼저 gdb, qemu 등 패키지들을 설치한다.\nUbuntu의 경우 다음 명령을 실행한다.\n$ sudo apt install gdb qemu-system-x86 curl git libncurses5-dev build-essential libssl-dev bc flex bison libelf-dev Linux kernel 다운로드 Linux kernel 빌드를 위해 kernel.org 또는 github 에서 소스 코드를 다운로드 받는다.\n$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git Linux kernel 설정 Linux 기본 설정파일을 세팅하고 kvm 가속 설정을 한다.\n디버깅에 필요한 디버깅 심볼과 GDB용 스크립트를 설정한다.\n$ cd linux $ make defconfig $ make kvm_guest.config $ sed -i \u0026#39;s/^# CONFIG_DEBUG_INFO is not set/CONFIG_DEBUG_INFO=y/\u0026#39; .config $ sed -i \u0026#39;s/^CONFIG_DEBUG_INFO_NONE=y/CONFIG_DEBUG_INFO=y\\n# CONFIG_DEBUG_INFO_NONE is not set/\u0026#39; .config $ sed -i \u0026#39;s/^# CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT is not set/CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y/\u0026#39; .config $ echo CONFIG_GDB_SCRIPTS=y \u0026gt;\u0026gt; .config $ make olddefconfig 커널 빌드 및 bzImage 복사 커널 이미지를 빌드한다.\n$ make -j`nproc` arch/x86_64/boot/bzImage : 심볼이 제거된 커널 이미지 vmlinux : 디버깅 심볼이 있는 커널 이미지 Ubuntu 다운로드 정상적으로 부팅해 shell까지 실행하려면 리눅스 배포판이 필요하다. ISO 설치 이미지로 배포판을 설치하거나 미리 설치된 이미지를 다운로드한다.\n여기서는 Ubuntu 이미지를 다운로드 받아 사용한다. Ubuntu cloud 등에서 이미지를 받으면 설치 시간을 단축할 수 있다.\n$ curl https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img -o ubuntu.img Linux kernel 디버깅 QEMU를 실행한다. -s와 -S 옵션 때문에 gdb 포트 1234를 열어둔 상태로 멈춰있다.\n$ qemu-system-x86_64 -smp 2 -m 512M -kernel $PWD/arch/x86/boot/bzImage -serial mon:stdio -append \u0026#34;root=/dev/sda1 console=ttyS0,115200 nokaslr\u0026#34; -drive file=ubuntu.img,index=0 -device e1000,netdev=net0 -netdev user,id=net0 -nographic -s -S GDB를 연결하고 심볼들을 로드한다.\n$ gdb (gdb) set auto-load safe-path . (gdb) add-auto-load-safe-path . (gdb) file vmlinux Reading symbols from vmlinux... (gdb) target remote localhost:1234 Remote debugging using localhost:1234 0x000000000000fff0 in exception_stacks () (gdb) break start_kernel Breakpoint 1 at 0xffffffff82fb8c19: file init/main.c, line 930. (gdb) continue ... lx-iomem : IO 메모리를 보여준다. lx-cpus : cpu 상태를 보여준다. lx-ps : 현재 프로세스를 보여준다. lx-cmdline : cmdline 을 보여준다. lx-dmesg : 커널 메세지를 보여준다. 기타 -cpu host -accel kvm 명령어로 kvm 활성화하면 빠르다. 하지만 break가 안되서 hbreak를 사용해야 한다. storage와 network를 virtio 등으로 로드하면 조금 더 빠른 설정이 가능하다. Ubuntu cloud 이미지를 실행하면 일부 설정 에러 메세지가 뜬다. cloud-util과 cloud-config로 초기화하면 에러메세지를 없앨수 있다. QEMU의 console 단축키는 Ctrl-a c 다. quit 명령어로 종료가 가능하다. References https://www.kernel.org/doc/html/v5.19/dev-tools/gdb-kernel-debugging.html\n","permalink":"https://zshchun.github.io/posts/qemu%EC%99%80-gdb%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-linux-kernel-%EB%94%94%EB%B2%84%EA%B9%85/","summary":"Linux kernel를 디버깅 하는 방법으로 QEMU와 JTAG을 이용한","title":"QEMU와 GDB를 이용한 Linux Kernel 디버깅"},{"content":"Git의 Hook 기능을 이용하면 commit되기 전에 자동으로 소스 파일을 검사하거나 메세지를 추가 할 수 있다.\nGit 커밋시 간단한 메세지를 자동으로 추가해보자.\n저장소 생성 먼저 git 저장소를 생성한다.\n$ mkdir repo $ cd repo $ git init Initialized empty Git repository in /repo/.git/ Hook 예제 .git/hooks 디렉토리에 hooks 예제 파일들이 있다.\n$ cd .git/hooks $ ls -1 .git/hooks applypatch-msg.sample commit-msg.sample fsmonitor-watchman.sample post-update.sample pre-applypatch.sample pre-commit.sample pre-merge-commit.sample pre-push.sample pre-rebase.sample pre-receive.sample prepare-commit-msg.sample push-to-checkout.sample update.sample Hooks Commit message 수정이 목적이니 관련 hook만 살펴보자.\npre-commit (\u0026ndash;no-verify) commit 전에 검사를 수행하기 위한 hook pre-merge-commit (\u0026ndash;no-verify) merge 실행 뒤 commit 실행 전에 호출되는 hook prepare-commit-msg 기본 commit 메세지가 준비된 뒤 에디터 편집 전에 호출되는 hook commit-msg (\u0026ndash;no-verify) commit 메세지를 형식에 맞게 정규화 하고 commit을 거부하기 위한 hook post-commit commit 메세지가 생성된 뒤 알림용 hook \u0026ndash;no-verify가 표시된 hook은 해당 옵션이 있으면 실행되지 않는다.\n메세지 추가 prepare-commit-msg 파일을 편집해 파일목록에 날짜와 메세지를 출력하는 hook을 작성해보자.\n예제 스크립트는 Commit message의 경로를 전달하는 첫번째 파라미터($1)를 변수 COMMIT_MSG_FILE에 저장하고 기본 메세지 Please enter the commit message를 삭제한다.\n$ cat prepare-commit-msg.sample ... COMMIT_MSG_FILE=$1 COMMIT_SOURCE=$2 SHA1=$3 /usr/bin/perl -i.bak -ne \u0026#39;print unless(m/^. Please enter the commit message/..m/^#$/)\u0026#39; \u0026#34;$COMMIT_MSG_FILE\u0026#34; ... 먼저 예제 파일 prepapre-commit-msg.sample 를 prepapre-commit-msg 로 복사한다.\n$ cp prepare-commit-msg.sample prepare-commit-msg prepare-commit-msg 파일의 perl 라인 뒤에 아래 명령어를 추가하면 날짜와 Awesome 메세지가 출력된다.\nsed -i \u0026#34;1i `date +%Y-%m-%d` Awesome `git diff --cached --name-only -r`\u0026#34; \u0026#34;$COMMIT_MSG_FILE\u0026#34; Commit 변경한 hook과 함께 실제 커밋을 해보자.\n$ touch foo $ git add foo $ git commit -a 메세지에 날짜와 메세지가 출력된다.\n2022-09-10 Awesome foo # On branch master # Changes to be committed: # new file: foo # 여기서는 단일 파일을 커밋했지만 다수 파일을 커밋할 경우 스크립트에서 처리해주면 된다.\n주의할 점은 자동으로 생성된 메세지에 내용이 있으면 자동으로 커밋 된다.\n메세지 편집 도중에 취소하고 싶은 경우 내용을 주석처리하고 저장하면 된다.\n참조 https://git-scm.com/docs/githooks\n","permalink":"https://zshchun.github.io/posts/git%EC%97%90-commit%EC%8B%9C-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EB%A9%94%EC%84%B8%EC%A7%80-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/","summary":"Git의 Hook 기능을 이용하면 commit되기 전에 자동으로 소스 파일","title":"Git에 commit시 자동으로 메세지 추가하기"},{"content":"musl은 glibc와 같은 C 표준 라이브러리로 가볍고 빠른 것이 특징이다.\nmusl 툴체인으로 빌드하려면 prebuilt 바이너리와 직접 빌드하는 방법이 있다.\nmusl.cc 사이트에서 비공식 prebuilt 바이너리 다운로드 musl-cross-make를 받아 가이드를 참조해 직접 빌드 여기서는 musl.cc에서 prebuilt 바이너리를 받아 컴파일 하는 방법을 설명한다.\n빌드 방법 // hello_world.c #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\\n\u0026#34;); return 0; } x86-64 환경에서 네이티브로 빌드를 하려면 musl.cc 바이너리 에서\nx86_64-linux-musl-native.tgz 를 다운받는다.\n$ cd x86_64-linux-musl-native/bin $ ./gcc hello_world.c arm64 타겟의 크로스컴파일은 aarch64-linux-musl-cross.tgz를 다운로드 받아 실행한다.\n$ cd aarch64-linux-musl-cross/bin $ ./aarch64-linux-musl-gcc hello_world.c Binary size x86_64 시스템에서 hello_world.c 바이너리 크기를 비교해 보았다.\nmusl size glibc size musl+gcc 7,528 glibc+gcc 15,960 musl+gcc (static) 15,328 glibc+gcc (static) 900,304 정적으로 빌드 했을때 파일 용량 차이가 큰 것을 확인할 수 있다. 작은 바이너리가 필요할 때 유용하다.\nVersion musl: git-b76f37f, gcc: 11.2.1 glibc: 2.35, gcc: 11.2.0 ","permalink":"https://zshchun.github.io/posts/musl-gcc%EB%A1%9C-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0/","summary":"musl은 glibc와 같은 C 표준 라이브러리로 가볍고 빠른 것이 특","title":"musl+gcc로 빌드하기"},{"content":"mprotect는 메모리 영역에 대한 권한을 수정할 수 있다.\n페이지에 실행 권한(PROT_EXEC)을 주면 메모리 상에서 코드를 실행할 수 있다.\n간단한 C 코드로 메모리 상에서 Hello World를 실행해보자.\npayload는 stdout(fd=1)으로 \u0026ldquo;Hello World\u0026rdquo; 을 출력하고 종료(exit)한다.\n컴파일과 실행은 다음과 같다.\n$ gcc mprotect-hello-world.c -o mprotect-hello-world $ ./mprotect-hello-world Hello World ARM 바이너리를 실행하려면 Ubuntu 기준으로 qemu-user와 컴파일러를 설치하면 된다.\n$ sudo apt install qemu-user gcc-aarch64-linux-gnu ARM64 바이너리의 실행은 다음 명령으로 실행할 수 있다.\n$ aarch64-linux-gnu-gcc -static test.c -o test $ qemu-aarch64 ./test Hello World ","permalink":"https://zshchun.github.io/posts/mprotect%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89/","summary":"mprotect는 메모리 영역에 대한 권한을 수정할 수 있다. 페이지","title":"mprotect를 이용한 코드 실행"},{"content":"파이썬 스크립트에서 시작시간이 좀 느려서 최적화를 해보았다.\n파이썬에는 실행시간 측정을 위해 cProfile과 -X importime 과 같은 좋은 기능이 있다.\n여기서는 먼저 라이브러리 시작시 로딩 시간을 알아보기 위해 사용되는 라이브러리를 확인했다.\n$ grep import * | cut -d: -f2 | cut -d\\ -f2 | sort | uniq aiohttp argparse asyncio concurrent.futures ... 간단한 스크립트로 사용되는 라이브러리들의 import time을 확인했다.\n#!/bin/bash for module in aiohttp argparse asyncio \\ concurrent.futures Cryptodome.Cipher \\ datetime getpass json lxml operator \\ os random re sqlite3 subprocess sys \\ time tomli websockets bs4 do (time python3 -c \u0026#34;import $module\u0026#34;) 2\u0026gt;\u0026amp;1 | \\ awk \u0026#34;/real/ {print sprintf(\\\u0026#34;%-20s\\\u0026#34;, \\\u0026#34;$module\\\u0026#34;) \\$2}\u0026#34; done | sort -drk 2 결과는 다음과 같다.\naiohttp 0m0.375s bs4 0m0.225s Cryptodome.Cipher 0m0.159s asyncio 0m0.084s concurrent.futures 0m0.036s tomli 0m0.033s websockets 0m0.027s argparse 0m0.027s subprocess 0m0.026s json 0m0.025s re 0m0.023s sqlite3 0m0.021s getpass 0m0.021s random 0m0.018s datetime 0m0.017s lxml 0m0.016s operator 0m0.015s sys 0m0.015s time 0m0.014s os 0m0.014s aiohttp, beautifulsoup, Cryptodome 세 라이브러리만 벌써 750ms 이상 사용하고 있었다.\nAES 암호화를 위한 Cryptodome.Cipher는 당장 필요가 없어 제거했다. 필요한 경우 import time이 짧은 cryptography나 pyaes로 대체 가능하다.\n비동기 HTTP 클라이언트/서버 라이브러리인 aiohttp과 유사한 경량화 클라이언트인 aiosonic으로 교체해 보았지만 아쉬운 부분이 있어 aiohttp를 사용하기로 했다.\nHTML 파싱을 위한 Beautiful Soup은 lxml으로 대체해서 200ms 단축하였다.\n결과적으로 프로그램 시작 시간을 대략 300ms가량 아낄수 있었다.\n","permalink":"https://zshchun.github.io/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC-import-time-%EC%B5%9C%EC%A0%81%ED%99%94/","summary":"파이썬 스크립트에서 시작시간이 좀 느려서 최적화를 해보았다. 파이썬","title":"파이썬 import time 최적화"},{"content":"확장된 기능을 제공하는 /bin/bash 대신 /bin/sh를 사용해야 하는 경우가 있다.\n기능 차이로 일부 문법은 의도하지 않은 결과가 발생할 수 있다.\nsh와 bash의 문법 차이를 살펴보자.\n1. [[ ]] 의 유무 [[ ]] 는 sh POSIX 표준이 아니다.\n조건 표현식 [ \u0026ldquo;$a\u0026rdquo; = \u0026ldquo;$b\u0026rdquo; ] 와 같이 단일 대괄호 [ ] 를 사용하는 편이 좋다.\n2. == 와 = 프로그래밍 언어에서 사용하는 ==는 sh에서 사용할 수 없다. 호환성을 위해 =를 사용하는 편이 좋다.\n-eq -gt -le 와 같은 숫자 비교 식은 사용할 수 있다.\n3. source의 유무 sh에는 source가 없다. 대신 . 만을 사용한다.\n4. (( )) 계산식 $(( )) 계산식은 일부 동작하고 (( )) 단일로는 동작하지 않는다.\n물론 for ((i=0;i\u0026lt;3;i++)) 와 같은 반복문도 동작하지 않는다.\n5. ${ } 변수 중괄호를 이용한 ${a} 와 ${a%pattern}, ${a#pattern} 와 같은 파라미터 확장은 동작한다.\n6. 추가식 a+=STRING 과 같은 변수 추가는 불가능하다.\na=${a}STRING 과 같이 추가해야 한다.\n7. 배열 bash의 a=(a b c) 와 같은 배열은 sh에서 동작하지 않는다. 필요한 경우 set을 이용해 비슷하게 사용해야 한다.\nReferences https://stackoverflow.com/questions/5725296/difference-between-sh-and-bash https://drewdevault.com/2018/02/05/Introduction-to-POSIX-shell.html https://www.baeldung.com/linux/posix-shell-array ","permalink":"https://zshchun.github.io/posts/bin/sh%EC%99%80-/bin/bash%EC%9D%98-%EC%B0%A8%EC%9D%B4/","summary":"확장된 기능을 제공하는 /bin/bash 대신 /bin/sh를 사용해야 하는 경우가","title":"/bin/sh와 /bin/bash의 차이"},{"content":"C++에서는 큰 숫자에서 가독성을 위해 구분자를 사용할 수 있다.\nC++는 C++14부터 \u0026lsquo;(single quote)를 구분자로 사용할 수 있다.\n// g++ --std=c++14 test.cpp || clang++ --std=c++14 test.cpp #include \u0026lt;iostream\u0026gt; int main() { int i = 1\u0026#39;234\u0026#39;567\u0026#39;890; std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; return 0; } Python은 3.6 버전부터 _(underscore)를 구분자로 사용할 수 있다.\ni = 1_234_567_890 print(i) 결과 1234567890 References cppreference Integer literal Stackoverflow C++ PEP-515 Stackoverflow Python ","permalink":"https://zshchun.github.io/posts/%ED%81%B0-%EC%88%AB%EC%9E%90%EC%9D%98-%EA%B5%AC%EB%B6%84%EC%9E%90/","summary":"C++에서는 큰 숫자에서 가독성을 위해 구분자를 사용할 수 있다. C+","title":"큰 숫자의 구분자"},{"content":"표준 C 라이브러리를 통하지 않고 linux syscall을 직접 핸들링해야 하는 경우 아키텍처에 따라 syscall 번호가 다르다.\nSyscall 번호는 linux 소스코드 또는 glibc, musl, bionic과 같은 C 표준 라이브러리 코드에서 확인할 수 있다.\n종종 필요한 경우가 있어 목록을 정리해둔다.\n다음 목록에서 확인할 수 있다.\nChromium Linux System Call Table glibc arm syscall glibc arm64 syscall glibc x86 syscall glibc x86_64 syscall ","permalink":"https://zshchun.github.io/posts/linux-syscall-list-x86/arm/","summary":"표준 C 라이브러리를 통하지 않고 linux syscall을 직접 핸들링해야","title":"Linux syscall list (x86/arm)"},{"content":"변수에서 Bit에서 0이나 1의 위치 또는 갯수를 구하는 경우 컴파일러는 내장 함수들을 지원한다.\nGCC나 Clang에서 간단한 코드를 살펴보자.\n#include \u0026lt;stdio.h\u0026gt; // for i in range(22): print(\u0026#39;\u0026#34;{}\u0026#34;, \u0026#39;.format(re.sub(r\u0026#39;(\\d{4})\u0026#39;, r\u0026#39;\\1 \u0026#39;, bin(i)[2:].rjust(32, \u0026#39;0\u0026#39;)).rstrip()), end=\u0026#39;\u0026#39;) char *bits[] = { \u0026#34;0000 0000 0000 0000 0000 0000 0000 0000\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0001\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0010\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0011\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0100\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0101\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0110\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0111\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1000\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1001\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1010\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1011\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1100\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1101\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1110\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1111\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0000\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0001\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0010\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0011\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0100\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0101\u0026#34; }; int main() { for (int i=0;i\u0026lt;21;i++) { printf(\u0026#34;%s clz: %d ffs: %d popcount: %d\\n\u0026#34;, \\ bits[i], \\ __builtin_clz(i), \\ __builtin_ffs(i), \\ __builtin_popcount(i)); } return 0; } Output 0000 0000 0000 0000 0000 0000 0000 0000 clz: 31 ffs: 0 popcount: 0 0000 0000 0000 0000 0000 0000 0000 0001 clz: 31 ffs: 1 popcount: 1 0000 0000 0000 0000 0000 0000 0000 0010 clz: 30 ffs: 2 popcount: 1 0000 0000 0000 0000 0000 0000 0000 0011 clz: 30 ffs: 1 popcount: 2 0000 0000 0000 0000 0000 0000 0000 0100 clz: 29 ffs: 3 popcount: 1 0000 0000 0000 0000 0000 0000 0000 0101 clz: 29 ffs: 1 popcount: 2 0000 0000 0000 0000 0000 0000 0000 0110 clz: 29 ffs: 2 popcount: 2 0000 0000 0000 0000 0000 0000 0000 0111 clz: 29 ffs: 1 popcount: 3 0000 0000 0000 0000 0000 0000 0000 1000 clz: 28 ffs: 4 popcount: 1 0000 0000 0000 0000 0000 0000 0000 1001 clz: 28 ffs: 1 popcount: 2 0000 0000 0000 0000 0000 0000 0000 1010 clz: 28 ffs: 2 popcount: 2 0000 0000 0000 0000 0000 0000 0000 1011 clz: 28 ffs: 1 popcount: 3 0000 0000 0000 0000 0000 0000 0000 1100 clz: 28 ffs: 3 popcount: 2 0000 0000 0000 0000 0000 0000 0000 1101 clz: 28 ffs: 1 popcount: 3 0000 0000 0000 0000 0000 0000 0000 1110 clz: 28 ffs: 2 popcount: 3 0000 0000 0000 0000 0000 0000 0000 1111 clz: 28 ffs: 1 popcount: 4 0000 0000 0000 0000 0000 0000 0001 0000 clz: 27 ffs: 5 popcount: 1 0000 0000 0000 0000 0000 0000 0001 0001 clz: 27 ffs: 1 popcount: 2 0000 0000 0000 0000 0000 0000 0001 0010 clz: 27 ffs: 2 popcount: 2 0000 0000 0000 0000 0000 0000 0001 0011 clz: 27 ffs: 1 popcount: 3 0000 0000 0000 0000 0000 0000 0001 0100 clz: 27 ffs: 3 popcount: 2 사용한 내장 함수들이다.\n__builtin_clz : 상위 비트(MSB)부터 0의 갯수, 입력 0에 대해 보장하지 않음 (undefined) __builtin_ffs : 하위 비트(LSB)부터 첫번째 1의 위치, 못찾으면 0 __builtin_popcount : 비트 1의 갯수 clz는 0의 경우도 1인 경우도 31인 것을 볼 수 있다. 0인 경우 처리를 해야한다.\n이 외에 ctz 등의 함수도 있다.\n__builtin_ctz : 하위 비트(LSB)부터 0의 갯수, 입력 0에 대해 보장하지 않음 (undefined) Assembly 내장 함수들이 어셈블리에서 어떻게 처리되는지 살펴보자.\nx86 64비트\n# gcc -O2 -S -march=native test.c ... tzcntl %ebx, %r8d popcntl %ebx, %r9d lzcntl %ebx, %ecx x86 32비트\n# gcc -O2 -m32 -S test.c ... pushl %esi call __popcountsi2@PLT xorl %edx, %edx addl $16, %esp rep bsfl %esi, %edx addl $1, %edx bsrl %esi, %ecx xorl $31, %ecx arm 64비트\n# aarch64-linux-gnu-gcc -O2 -S test.c ... cnt v0.8b, v0.8b rbit w4, w19 clz w4, w4 clz w3, w19 add w4, w4, 1 add x19, x19, 1 addv b0, v0.8b 아키텍처에 따라 다음 어셈블리 명령어를 사용하는 것을 확인할 수 있다.\nx86 : bsf, bsr x86_64 : tzcnt, popcnt, lzcnt arm64 : clz, cnt 이처럼 아키텍처마다 instruction 레벨에서 bit 연산을 지원 한다.\n기타 위의 내장 함수들은 32비트 기준이며 long 타입과 long long 타입은 __builtin_ffsll과 같이 l, ll 접미사를 붙여줘야 한다.\n*nix 계열에서는 LP64 모델을 사용하며 L, LL, ULL 등의 접미사를 사용하면 64비트가 된다.\n1 대신 0을 찾는등 반대의 경우는 Bitwise NOT(~) 연산으로 비트를 뒤집으면 된다.\n그 외에도 아래의 popcount 구현처럼 많은 bit hack들이 존재한다.\nint swar(uint32_t i) { i = i - ((i \u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); return (((i + (i \u0026gt;\u0026gt; 4)) \u0026amp; 0x0F0F0F0F) * 0x01010101) \u0026gt;\u0026gt; 24; } 더 관심이 있다면 Bit Twiddling Hacks이나 Linux 소스코드 등 에서 더 많은 것을 찾아볼 수 있다.\nReferences Wiki: Find first set GCC builtin extensions\n","permalink":"https://zshchun.github.io/posts/%EC%9C%A0%EC%9A%A9%ED%95%9C-bit-%EA%B4%80%EB%A0%A8-%ED%95%A8%EC%88%98/","summary":"변수에서 Bit에서 0이나 1의 위치 또는 갯수를 구하는 경우 컴파일러","title":"유용한 bit 관련 함수"},{"content":"비교 map unordered_map 순서 오름차순 정렬 정렬 없음 구현 트리 구조 해시 테이블 탐색 시간 log(n) O(1) 삽입 시간 log(n) O(1) 요약 map은 정렬 순서를 보장하고 unordered_map은 그렇지 않다. unordered_map은 map보다 속도가 빠르고 hash 기반이다. map은 BST(Binary Search Tree) 기반이며 해시 충돌에서 안전하다. set과 unordered_set도 동일하게 트리, 해시 기반이다. multimap과 multiset은 BST 기반이다. References map vs unordered map set vs unordered set\n","permalink":"https://zshchun.github.io/posts/map%EA%B3%BC-unordered-map%EC%9D%98-%EC%B0%A8%EC%9D%B4/","summary":"비교 map unordered_map 순서 오름차순 정렬 정렬 없음 구현 트리 구조 해시 테이블 탐색 시","title":"map과 unordered map의 차이"},{"content":"std::accumulate() 결과가 예상과 다른 경우가 있다.\n간단한 합을 구하는 코드를 살펴보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(int argc, char **argv) { long long sum1 = 0; long long sum2 = 0; vector\u0026lt;long\u0026gt; v; v.push_back(1234567890); v.push_back(2345678901); v.push_back(3456789012); for (int i=0;i\u0026lt;v.size();i++) sum1 += v[i]; sum2 = accumulate(v.begin(), v.end(), 0); cout \u0026lt;\u0026lt; \u0026#34;sum1: \u0026#34; \u0026lt;\u0026lt; sum1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sum2: \u0026#34; \u0026lt;\u0026lt; sum2 \u0026lt;\u0026lt; endl; return 0; } for를 통한 합과 accumulate() 의 결과가 서로 다르게 나오는 것을 알 수 있다.\nsum1: 7037035803 sum2: -1552898789 accumulate()의 반환값은 초기값 0의 타입(int)을 따라간다. 합계가 int 범위를 초과하면 상수값 뒤에 LL을 붙여 0LL(=long long)이나 0ULL(unsigned long long)을 사용해야 한다. (ll, ull 소문자도 가능)\nsum2 = accumulate(v.begin(), v.end(), 0LL); 참고 cppreference\ntemplate\u0026lt; class InputIt, class T \u0026gt; T accumulate( InputIt first, InputIt last, T init ); ","permalink":"https://zshchun.github.io/posts/stdaccumulate-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%9C%A0%EC%9D%98%EC%82%AC%ED%95%AD/","summary":"std::accumulate() 결과가 예상과 다른 경우가 있다. 간단한 합을 구하는 코드를 살펴보자","title":"std::accumulate 사용시 유의사항"},{"content":"Windows terminal 에서 shift-enter, shift-alt-enter 키입력을 위해서는 settings.json 에서 다음을 추가한다.\nWindows terminal -\u0026gt; 설정 -\u0026gt; Json 파일 열기 { \u0026#34;command\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;sendInput\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;\\u001b[13;2u\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;shift+enter\u0026#34; }, { \u0026#34;command\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;sendInput\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;\\u001b[13;5u\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+enter\u0026#34; }, { \u0026#34;command\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;sendInput\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;\\u001b[13;6u\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+enter\u0026#34; }, { \u0026#34;command\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;sendInput\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;\\u001b\\u001b[13;2u\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;shift+alt+enter\u0026#34; }, 참조 Shift+Enter always submits, breaking PSReadline features ANSI Escape Sequences\n","permalink":"https://zshchun.github.io/posts/windows-terminal-wsl2-%EC%97%90%EC%84%9C-shift-enter-%EC%9E%85%EB%A0%A5%EB%B0%A9%EB%B2%95/","summary":"Windows terminal 에서 shift-enter, shift-alt-enter 키입력을 위해서는 settings.json 에서 다음을 추가한다. Windows terminal -\u0026gt; 설정","title":"Windows Terminal+WSL2 에서 shift-enter 입력방법"},{"content":"목적 AES 대칭키 알고리즘은 아키텍처에서 AES-NI와 같은 HW 가속 instruction set을 제공하기도 한다.\n라이브러리에서 AES 가속을 지원한다면 프로그램의 수행속도를 줄일 수 있다.\n검색 결과 AesManaged는 AES HW 가속을 지원하고 AesCryptoServiceProvider 클래스는 AES 가속을 지원하지 않는 것을 확인해 확인하기 위해 간단한 테스트를 하였다.\n가정 AES의 HW 가속은 순수 SW 연산보다 현저히 빠를 것이다. .NET에서 AesCryptoServiceProvider class는 HW 가속을 지원하며 AesManaged class는 지원하지 않을 것이다. 작은 크기의 많은 AES 연산에서는 overhead로 HW 가속이 더 느릴수 있다. .NET 4.8, 4KB x 100000 AES encryption 작은 크기에 큰 반복 횟수에서는 AesManaged가 더 빠른 결과를 보였다.\n.NET 4.8 1(ms) 2 3 4 5 AesManaged 4968 4940 4947 4971 4939 AesCryptoServiceProvider 6395 6407 6399 6323 6322 .NET 4.8, 1MB x 1000 AES encryption 큰 크기에 낮은 반복 횟수의 암호화는 AES 가속이 되는 AesCryptoServiceProvider 클래스가 월등히 유리하다. 클래스만 변경했을 때 12배 이상 차이가 나는 것을 확인했다.\n.NET 4.8 1(ms) 2 3 4 5 AesCryptoServiceProvider 1004 983 984 987 984 AesManaged 12468 12671 12436 12483 12436 Code Linux \u0026amp; OpenSSL 리눅스 에서는 openssl cli로 HW 가속을 테스트할 수 있다.\n가능한 경우 EVP_ 접두사 함수들은 기본적으로 AES-NI 를 사용하며 AES_ 접두사 함수들은 사용하지 않는다.\n64바이트 이상에서 속도가 3배 이상 차이나는 것을 확인할 수 있다.\n$ openssl speed -elapsed -evp aes-128-cbc type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes aes-128-cbc 879157.61k 1346181.01k 1409330.52k 1448567.47k 1479671.81k 1460371.46k $ OPENSSL_ia32cap=\u0026#34;~0x200000200000000\u0026#34; openssl speed -elapsed -evp aes-128-cbc type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes aes-128-cbc 409826.10k 425150.51k 428506.71k 429743.79k 429782.36k 429725.01k 결론 .NET 4.8 에서는 AesCryptoServiceProvider 쪽을 사용하는 것이 대개의 경우 더 유리하다. .NET 6.0도 테스트했지만 두 클래스의 속도가 400-600ms로 비슷한 결과가 나왔다. 6.0에서는 AesCryptoServiceProvider 클래스도 HW 가속을 지원하는 것이 아닐까 추측한다. References https://www.codeproject.com/Tips/844795/Measuring-the-performance-of-AES-implementations-i https://odetocode.com/blogs/scott/archive/2014/02/24/symmetric-encryption-benchmarks-with-c.aspx https://stackoverflow.com/questions/23444135/is-net-aesmanaged-cryptography-hardware-accelerated https://stackoverflow.com/questions/25284119/how-can-i-check-if-openssl-is-support-use-the-intel-aes-ni ","permalink":"https://zshchun.github.io/posts/net%EC%9D%98-aes-hw-%EA%B0%80%EC%86%8D-%EC%A7%80%EC%9B%90/","summary":"목적 AES 대칭키 알고리즘은 아키텍처에서 AES-NI와 같은 HW 가속 instruction","title":"NET의 AES HW 가속 지원"},{"content":"목표 대용량 텍스트의 압축 크기와 해제 속도의 수용가능한 절충점 찾기 multithreading 옵션과 압축 레벨을 이용하지 않고 기본 옵션으로 비교 압축 해제 속도만 측정 script #!/bin/bash testfile=test.txt declare -A ext_array=([Z]=compress [gz]=gzip [xz]=xz [lz]=lzip [bz2]=bzip2 [zst]=zstd [lzma]=lzma [lz4]=lz4) for ext in ${!ext_array[@]} do prog=${ext_array[$ext]} ls -sh $testfile.$ext time $prog -dc $testfile.$ext \u0026gt; /dev/null done samples (1-2GB) name size(MB) time(sec) name size(MB) time(sec) lz4 120 0.591 lz4 271 1.159 zstd 47 0.786 zstd 132 1.850 lzma 26 1.638 lzma 84 4.743 xz 26 2.473 gzip 152 4.820 gzip 67 2.694 xz 84 6.124 Lempel-Ziv 110 3.679 Lempel-Ziv 192 6.258 lzip 27 3.932 lzip 86 9.609 bzip2 42 7.724 bzip2 95 16.014 결론 속도는 lz4가 가장 빠르지만 압축률이 낮다.\n크기와 속도의 절충점으로 zstd나 lzma 정도가 대안이 된다.\nxz가 압축률이 가장 좋고 bzip2은 모든 면에서 이점이 없다.\n참조 Comparison of Compression Algorithms\n","permalink":"https://zshchun.github.io/posts/text-%EC%95%95%EC%B6%95-%ED%95%B4%EC%A0%9C-%EC%86%8D%EB%8F%84-%EB%B9%84%EA%B5%90/","summary":"목표 대용량 텍스트의 압축 크기와 해제 속도의 수용가능한 절충점 찾기 multithreading","title":"Text 압축 해제 속도 비교"}]