[{"content":"파이썬 스크립트에서 시작시간이 좀 느려서 최적화를 해보았다.\n파이썬에는 실행시간 측정을 위해 cProfile과 -X importime 과 같은 좋은 기능이 있다.\n여기서는 실행 시간보다 라이브러리의 로딩 시간을 알아보기 위해 먼저 사용되는 라이브러리를 확인했다.\n1$ grep import * | cut -d: -f2 | cut -d\\  -f2 | sort | uniq 2 3aiohttp 4argparse 5asyncio 6concurrent.futures 7... 스크립트로 사용되는 라이브러리들의 import time을 확인할 수 있었다.\n1#!/bin/bash 2for module in aiohttp argparse asyncio \\ 3 concurrent.futures Cryptodome.Cipher \\ 4 datetime getpass json lxml operator \\ 5 os random re sqlite3 subprocess sys \\ 6 time tomli websockets bs4 7do 8 (time python3 -c \u0026#34;import $module\u0026#34;) 2\u0026gt;\u0026amp;1 | \\ 9 awk \u0026#34;/real/ {print sprintf(\\\u0026#34;%-20s\\\u0026#34;, \\\u0026#34;$module\\\u0026#34;) \\$2}\u0026#34; 10done | sort -drk 2 결과는 다음과 같다.\naiohttp 0m0.375s bs4 0m0.225s Cryptodome.Cipher 0m0.159s asyncio 0m0.084s concurrent.futures 0m0.036s tomli 0m0.033s websockets 0m0.027s argparse 0m0.027s subprocess 0m0.026s json 0m0.025s re 0m0.023s sqlite3 0m0.021s getpass 0m0.021s random 0m0.018s datetime 0m0.017s lxml 0m0.016s operator 0m0.015s sys 0m0.015s time 0m0.014s os 0m0.014s 시작 시간을 많이 차지하는 aiohttp, beautifulsoup, Cryptodome 세 라이브러리만 벌써 0.75 초를 사용하고 있었다.\nAES가 목적인 Cryptodome.Cipher는 당장 필요가 없어 제거했다. 필요한 경우 import time이 짧은 cryptography나 pyaes로 대체 가능하다.\nHTTP 클라이언트/서버 라이브러리인 aiohttp에 비해 경량화 클라이언트인 aiosonic으로 교체해 보았지만 아쉬운 부분이 있어서 남겨두었다.\nHTML 파싱을 위한 Beautiful Soup은 lxml으로 대체해서 0.2s 정도 단축할 수 있었다.\n일부 컴퓨터 환경에서 시작 시간이 대략 0.3초 정도 줄어들었다.\n","permalink":"https://zshchun.github.io/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC-import-time-%EC%B5%9C%EC%A0%81%ED%99%94/","summary":"파이썬 스크립트에서 시작시간이 좀 느려서 최적화를 해보았다. 파이썬","title":"파이썬 import time 최적화"},{"content":"bash shell 대신 /bin/sh를 사용해야 하는 경우가 있다.\nsh와 bash의 문법 차이를 살펴보자.\n1. [[ ]] 의 유무 [[ ]] 는 sh POSIX 표준이 아니다.\n조건 표현식 [ \u0026ldquo;$a\u0026rdquo; = \u0026ldquo;$b\u0026rdquo; ] 와 같이 단일 대괄호 [ ] 를 사용하는 편이 좋다.\n2. == 와 = 프로그래밍 언어에서 사용하는 ==는 sh에서 사용할 수 없다. 호환성을 위해 =를 사용하는 편이 좋다.\n-eq -gt -le 와 같은 숫자 비교 식은 사용할 수 있다.\n3. source의 유무 sh에는 source가 없다. 대신 . 만을 사용한다.\n4. (( )) 계산식 $(( )) 계산식은 일부 동작하고 (( )) 단일로는 동작하지 않는다.\n물론 for ((i=0;i\u0026lt;3;i++)) 와 같은 반복문도 동작하지 않는다.\n5. ${ } 변수 중괄호를 이용한 ${a} 와 ${a%pattern}, ${a#pattern} 와 같은 파라미터 확장은 동작한다.\n6. 추가식 a+=STRING 과 같은 변수 추가는 불가능하다.\na=${a}STRING 과 같이 추가해야 한다.\n7. 배열 a=(a b c) 와 같은 배열은 동작하지 않는다. set을 이용해 비슷하게 사용할 수는 있다.\nReferences  https://stackoverflow.com/questions/5725296/difference-between-sh-and-bash https://drewdevault.com/2018/02/05/Introduction-to-POSIX-shell.html https://www.baeldung.com/linux/posix-shell-array  ","permalink":"https://zshchun.github.io/posts/bin/sh%EC%99%80-/bin/bash%EC%9D%98-%EC%B0%A8%EC%9D%B4/","summary":"bash shell 대신 /bin/sh를 사용해야 하는 경우가 있다. sh와 bas","title":"/bin/sh와 /bin/bash의 차이"},{"content":"C++에서는 큰 숫자에서 가독성을 위해 구분자를 사용할 수 있다.\nC++는 C++14부터 \u0026lsquo;(single quote)를 구분자로 사용할 수 있다.\n1// g++ --std=c++14 test.cpp || clang++ --std=c++14 test.cpp 2#include \u0026lt;iostream\u0026gt;3 4int main() { 5 int i = 1\u0026#39;234\u0026#39;567\u0026#39;890; 6 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 7 return 0; 8} Python은 3.6 버전부터 _(underscore)를 구분자로 사용할 수 있다.\n1i = 1_234_567_890 2print(i) 결과 1234567890 References C++\n cppreference Integer literal Stackoverflow C++  Python\n Stackoverflow Python PEP-515  ","permalink":"https://zshchun.github.io/posts/%ED%81%B0-%EC%88%AB%EC%9E%90%EC%9D%98-%EA%B5%AC%EB%B6%84%EC%9E%90/","summary":"C++에서는 큰 숫자에서 가독성을 위해 구분자를 사용할 수 있다. C+","title":"큰 숫자의 구분자"},{"content":"Shellcode를 직접 만들거나 Linux syscall을 직접 핸들링해야 하는 경우 아키텍처에 따라 syscall 번호가 다르다.\nSyscall 번호는 리눅스 커널 소스코드 또는 glibc, musl, bionic과 같은 C 표준 라이브러리에서 찾아볼 수 있다.\n다음 목록에서 확인할 수 있다.\n  Chromium Linux System Call Table\n  glibc arm syscall\n  glibc arm64 syscall\n  glibc x86 syscall\n  glibc x86_64 syscall\n  ","permalink":"https://zshchun.github.io/posts/linux-syscall-list-x86/arm/","summary":"Shellcode를 직접 만들거나 Linux syscall을 직접 핸들링","title":"Linux syscall list (x86/arm)"},{"content":"bit의 위치나 갯수를 구하는 경우 gcc, clang등의 컴파일러는 내장 비트 연산 함수를 지원한다.\n간단한 코드를 살펴보자.\n1#include \u0026lt;stdio.h\u0026gt;2 3// for i in range(22): print(\u0026#39;\u0026#34;{}\u0026#34;, \u0026#39;.format(re.sub(r\u0026#39;(\\d{4})\u0026#39;, r\u0026#39;\\1 \u0026#39;, bin(i)[2:].rjust(32, \u0026#39;0\u0026#39;)).rstrip()), end=\u0026#39;\u0026#39;) 4char *bits[] = { \u0026#34;0000 0000 0000 0000 0000 0000 0000 0000\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0001\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0010\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0011\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0100\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0101\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0110\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 0111\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1000\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1001\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1010\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1011\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1100\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1101\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1110\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0000 1111\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0000\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0001\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0010\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0011\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0100\u0026#34;, \u0026#34;0000 0000 0000 0000 0000 0000 0001 0101\u0026#34; }; 5 6int main() { 7\tfor (int i=0;i\u0026lt;21;i++) { 8\tprintf(\u0026#34;%s clz: %d ffs: %d popcount: %d\\n\u0026#34;, \\ 9\tbits[i], \\ 10\t__builtin_clz(i), \\ 11\t__builtin_ffs(i), \\ 12\t__builtin_popcount(i)); 13\t} 14\treturn 0; 15} Output 0000 0000 0000 0000 0000 0000 0000 0000 clz: 31 ffs: 0 popcount: 0 0000 0000 0000 0000 0000 0000 0000 0001 clz: 31 ffs: 1 popcount: 1 0000 0000 0000 0000 0000 0000 0000 0010 clz: 30 ffs: 2 popcount: 1 0000 0000 0000 0000 0000 0000 0000 0011 clz: 30 ffs: 1 popcount: 2 0000 0000 0000 0000 0000 0000 0000 0100 clz: 29 ffs: 3 popcount: 1 0000 0000 0000 0000 0000 0000 0000 0101 clz: 29 ffs: 1 popcount: 2 0000 0000 0000 0000 0000 0000 0000 0110 clz: 29 ffs: 2 popcount: 2 0000 0000 0000 0000 0000 0000 0000 0111 clz: 29 ffs: 1 popcount: 3 0000 0000 0000 0000 0000 0000 0000 1000 clz: 28 ffs: 4 popcount: 1 0000 0000 0000 0000 0000 0000 0000 1001 clz: 28 ffs: 1 popcount: 2 0000 0000 0000 0000 0000 0000 0000 1010 clz: 28 ffs: 2 popcount: 2 0000 0000 0000 0000 0000 0000 0000 1011 clz: 28 ffs: 1 popcount: 3 0000 0000 0000 0000 0000 0000 0000 1100 clz: 28 ffs: 3 popcount: 2 0000 0000 0000 0000 0000 0000 0000 1101 clz: 28 ffs: 1 popcount: 3 0000 0000 0000 0000 0000 0000 0000 1110 clz: 28 ffs: 2 popcount: 3 0000 0000 0000 0000 0000 0000 0000 1111 clz: 28 ffs: 1 popcount: 4 0000 0000 0000 0000 0000 0000 0001 0000 clz: 27 ffs: 5 popcount: 1 0000 0000 0000 0000 0000 0000 0001 0001 clz: 27 ffs: 1 popcount: 2 0000 0000 0000 0000 0000 0000 0001 0010 clz: 27 ffs: 2 popcount: 2 0000 0000 0000 0000 0000 0000 0001 0011 clz: 27 ffs: 1 popcount: 3 0000 0000 0000 0000 0000 0000 0001 0100 clz: 27 ffs: 3 popcount: 2 __builtin_clz : 상위 비트(MSB)부터 0의 갯수, 입력 0에 대해 보장하지 않음 (undefined) __builtin_ffs : 하위 비트(LSB)부터 첫번째 1의 위치, 못찾으면 0 __builtin_popcount : 비트 1의 갯수\nclz는 0의 경우도 1인 경우도 31인 것을 볼 수 있다. 0인 경우 처리를 해야한다.\n이 외에 ctz 등의 함수도 있다.\n__builtin_ctz : 하위 비트(LSB)부터 0의 갯수, 입력 0에 대해 보장하지 않음 (undefined)\nAssembly 1# gcc -O2 -S -march=native test.c 2... 3 tzcntl %ebx, %r8d 4 popcntl %ebx, %r9d 5 lzcntl %ebx, %ecx 1# gcc -O2 -m32 -S test.c 2... 3 pushl %esi 4 call __popcountsi2@PLT 5 xorl %edx, %edx 6 addl $16, %esp 7 rep bsfl %esi, %edx 8 addl $1, %edx 9 bsrl %esi, %ecx 10 xorl $31, %ecx 1# aarch64-linux-gnu-gcc -O2 -S test.c 2... 3 cnt v0.8b, v0.8b 4 rbit w4, w19 5 clz w4, w4 6 clz w3, w19 7 add w4, w4, 1 8 add x19, x19, 1 9 addv b0, v0.8b  x86 : bsf, bsr x86_64 : tzcnt, popcnt, lzcnt arm64 : clz, cnt  등의 어셈블리 명령어가 사용되는 것을 볼 수 있다.\n이처럼 아키텍처마다 instruction 레벨에서 bit 연산을 지원 한다.\n기타 위의 내장 함수들은 32비트 기준이며 long 타입과 long long 타입은 __builtin_ffsll과 같이 l, ll 접미사를 붙인다.\n*nix 계열에서는 보통 LP64 모델을 사용하며 long 또는 long long을 사용하면 64비트가 된다.\n1 대신 0을 찾는등 반대의 경우는 Bitwise NOT(~) 연산으로 비트를 뒤집으면 된다.\n그 외에도 아래의 popcount 구현처럼 많은 bit hack들이 존재한다.\n1int swar(uint32_t i) { 2 i = i - ((i \u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); 3 i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); 4 return (((i + (i \u0026gt;\u0026gt; 4)) \u0026amp; 0x0F0F0F0F) * 0x01010101) \u0026gt;\u0026gt; 24; 5} 더 관심이 있다면 Bit Twiddling Hacks이나 Linux 소스코드 등 에서 더 많은 것을 찾아볼 수 있다.\nReferences Wiki: Find first set GCC builtin extensions\n","permalink":"https://zshchun.github.io/posts/%EC%9C%A0%EC%9A%A9%ED%95%9C-bit-%EA%B4%80%EB%A0%A8-%ED%95%A8%EC%88%98/","summary":"bit의 위치나 갯수를 구하는 경우 gcc, clang등의 컴파일러는 내장","title":"유용한 bit 관련 함수"},{"content":"요약  map은 순서를 보장하지만 unordered_map은 순서를 보장하지 않는다. unordered_map은 map보다 속도가 빠르지만 hash 기반이다. map은 tree 기반이라 해시 충돌에서 안전하다.  비교     map unordered_map     순서 오름차순 정렬 정렬 없음   구현 트리 구조 해시 테이블   탐색 시간 log(n) O(1)   삽입 시간 log(n) O(1)    References map vs unordered map set vs unordered set\n","permalink":"https://zshchun.github.io/posts/map%EA%B3%BC-unordered-map%EC%9D%98-%EC%B0%A8%EC%9D%B4/","summary":"요약 map은 순서를 보장하지만 unordered_map은 순서","title":"map과 unordered map의 차이"},{"content":"std::accumulate() 결과가 예상과 다른 경우가 있다.\n간단한 합을 구하는 코드를 살펴보자.\n1#include \u0026lt;iostream\u0026gt;2#include \u0026lt;numeric\u0026gt;3#include \u0026lt;vector\u0026gt;4using namespace std; 5 6int main(int argc, char **argv) { 7 long long sum1 = 0; 8 long long sum2 = 0; 9 10 vector\u0026lt;long\u0026gt; v; 11 v.push_back(1234567890); 12 v.push_back(2345678901); 13 v.push_back(3456789012); 14 15 for (int i=0;i\u0026lt;v.size();i++) 16 sum1 += v[i]; 17 18 sum2 = accumulate(v.begin(), v.end(), 0); 19 20 cout \u0026lt;\u0026lt; \u0026#34;sum1: \u0026#34; \u0026lt;\u0026lt; sum1 \u0026lt;\u0026lt; endl; 21 cout \u0026lt;\u0026lt; \u0026#34;sum2: \u0026#34; \u0026lt;\u0026lt; sum2 \u0026lt;\u0026lt; endl; 22 23 return 0; 24} for를 통한 합과 accumulate() 의 결과가 서로 다르게 나오는 것을 알 수 있다.\n1sum1: 7037035803 2sum2: -1552898789 accumulate()의 반환값은 초기값 0의 타입(int)을 따라간다. 합계가 int 범위를 초과하면 상수값 뒤에 LL을 붙여 0LL(=long long)이나 0ULL(unsigned long long)을 사용해야 한다. (ll, ull 소문자도 가능)\n1sum2 = accumulate(v.begin(), v.end(), 0LL); 참고 cppreference\n1template\u0026lt; class InputIt, class T \u0026gt; 2T accumulate( InputIt first, InputIt last, T init ); ","permalink":"https://zshchun.github.io/posts/stdaccumulate-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%9C%A0%EC%9D%98%EC%82%AC%ED%95%AD/","summary":"std::accumulate() 결과가 예상과 다른 경우가 있다. 간단한 합을 구하는 코드를 살펴보자","title":"std::accumulate 사용시 유의사항"},{"content":"Windows terminal 에서 shift-enter, shift-alt-enter 키입력을 위해서는 settings.json 에서 다음을 추가한다.\n Windows terminal -\u0026gt; 설정 -\u0026gt; Json 파일 열기  1{ \u0026#34;command\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;sendInput\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;\\u001b[13;2u\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;shift+enter\u0026#34; }, 2{ \u0026#34;command\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;sendInput\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;\\u001b[13;5u\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+enter\u0026#34; }, 3{ \u0026#34;command\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;sendInput\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;\\u001b[13;6u\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+enter\u0026#34; }, 4{ \u0026#34;command\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;sendInput\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;\\u001b\\u001b[13;2u\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;shift+alt+enter\u0026#34; }, 참조 Shift+Enter always submits, breaking PSReadline features ANSI Escape Sequences\n","permalink":"https://zshchun.github.io/posts/windows-terminal-wsl2-%EC%97%90%EC%84%9C-shift-enter-%EC%9E%85%EB%A0%A5%EB%B0%A9%EB%B2%95/","summary":"Windows terminal 에서 shift-enter, shift-alt-enter 키입력을 위해서는 settings.json 에서 다음을 추가한다. Windows terminal -\u0026gt; 설정","title":"Windows Terminal+WSL2 에서 shift-enter 입력방법"},{"content":"목적 AES 대칭키 알고리즘은 아키텍처에서 AES-NI와 같은 HW 가속 instruction set을 제공하기도 한다.\n라이브러리에서 AES 가속을 지원한다면 프로그램의 수행속도를 줄일 수 있다.\n검색 결과 AesManaged는 AES HW 가속을 지원하고 AesCryptoServiceProvider 클래스는 AES 가속을 지원하지 않는 것을 확인해 확인하기 위해 간단한 테스트를 하였다.\n가설  AES의 HW 가속은 순수 SW 연산보다 현저히 빠를 것이다. .NET에서 AesCryptoServiceProvider class는 HW 가속을 지원하며 AesManaged class는 지원하지 않을 것이다. 작은 크기의 많은 AES 연산에서는 overhead로 HW 가속이 더 느릴수 있다.  .NET 4.8, 4KB x 100000 AES encryption 작은 크기에 큰 반복 횟수에서는 AesManaged가 더 빠른 결과를 보였다.\n   .NET 4.8 1(ms) 2 3 4 5     AesManaged 4968 4940 4947 4971 4939   AesCryptoServiceProvider 6395 6407 6399 6323 6322    .NET 4.8, 1MB x 1000 AES encryption 큰 크기에 낮은 반복 횟수의 암호화는 AES 가속이 되는 AesCryptoServiceProvider 클래스가 월등히 유리하다. 클래스만 변경했을 때 12배 이상 차이가 나는 것을 확인했다.\n   .NET 4.8 1(ms) 2 3 4 5     AesCryptoServiceProvider 1004 983 984 987 984   AesManaged 12468 12671 12436 12483 12436    Code  Linux \u0026amp; OpenSSL 리눅스 에서는 openssl cli로 HW 가속을 테스트할 수 있다.\n가능한 경우 EVP_ 접두사 함수들은 기본적으로 AES-NI 를 사용하며 AES_ 접두사 함수들은 사용하지 않는다.\n64바이트 이상에서 속도가 3배 이상 차이나는 것을 확인할 수 있다.\n1$ openssl speed -elapsed -evp aes-128-cbc 2type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes 3aes-128-cbc 879157.61k 1346181.01k 1409330.52k 1448567.47k 1479671.81k 1460371.46k 4 5$ OPENSSL_ia32cap=\u0026#34;~0x200000200000000\u0026#34; openssl speed -elapsed -evp aes-128-cbc 6type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes 7aes-128-cbc 409826.10k 425150.51k 428506.71k 429743.79k 429782.36k 429725.01k 결론  .NET 4.8 에서는 AesCryptoServiceProvider 쪽을 사용하는 것이 대개의 경우 더 유리하다. .NET 6.0도 테스트했지만 두 클래스의 속도가 400-600ms로 비슷한 결과가 나왔다. 6.0에서는 AesCryptoServiceProvider 클래스도 HW 가속을 지원하는 것이 아닐까 추측한다.  References  https://www.codeproject.com/Tips/844795/Measuring-the-performance-of-AES-implementations-i https://odetocode.com/blogs/scott/archive/2014/02/24/symmetric-encryption-benchmarks-with-c.aspx https://stackoverflow.com/questions/23444135/is-net-aesmanaged-cryptography-hardware-accelerated https://stackoverflow.com/questions/25284119/how-can-i-check-if-openssl-is-support-use-the-intel-aes-ni  ","permalink":"https://zshchun.github.io/posts/net%EC%9D%98-aes-hw-%EA%B0%80%EC%86%8D-%EC%A7%80%EC%9B%90/","summary":"목적 AES 대칭키 알고리즘은 아키텍처에서 AES-NI와 같은 HW 가속 instruction","title":"NET의 AES HW 가속 지원"},{"content":"목표  대용량 텍스트의 압축 크기와 해제 속도의 수용가능한 절충점 찾기 multithreading 옵션과 압축 레벨을 이용하지 않고 기본 옵션으로 비교 압축 해제 속도만 측정  script 1#!/bin/bash 2testfile=test.txt 3declare -A ext_array=([Z]=compress [gz]=gzip [xz]=xz [lz]=lzip [bz2]=bzip2 [zst]=zstd [lzma]=lzma [lz4]=lz4) 4for ext in ${!ext_array[@]} 5do 6 prog=${ext_array[$ext]} 7 ls -sh $testfile.$ext 8 time $prog -dc $testfile.$ext \u0026gt; /dev/null 9done samples (1-2GB)    name size(MB) time(sec) name size(MB) time(sec)     lz4 120 0.591 lz4 271 1.159   zstd 47 0.786 zstd 132 1.850   lzma 26 1.638 lzma 84 4.743   xz 26 2.473 gzip 152 4.820   gzip 67 2.694 xz 84 6.124   Lempel-Ziv 110 3.679 Lempel-Ziv 192 6.258   lzip 27 3.932 lzip 86 9.609   bzip2 42 7.724 bzip2 95 16.014    결론 속도는 lz4가 가장 빠르지만 압축률이 낮다.\n크기와 속도의 절충점으로 zstd나 lzma 정도가 대안이 된다.\nxz가 압축률이 가장 좋고 bzip2은 모든 면에서 이점이 없다.\n참조 Comparison of Compression Algorithms\n","permalink":"https://zshchun.github.io/posts/text-%EC%95%95%EC%B6%95-%ED%95%B4%EC%A0%9C-%EC%86%8D%EB%8F%84-%EB%B9%84%EA%B5%90/","summary":"목표 대용량 텍스트의 압축 크기와 해제 속도의 수용가능한 절충점 찾기 multithreading","title":"Text 압축 해제 속도 비교"}]